## What’s a Task Queue? 啥是任务队列

任务队列被用作一个通过线程或机器分配工作的分发机制.

一个任务队列的输入被叫做一个工作单元. 专用的worker进程不断监控任务队列以执行新工作.

Celery通过消息进行交流, 通常使用一个broker(中间件)来调节客户端和workers(工作流). 要开启一个任务, 客户端添加一个消息到队列中, 然后broker发送这个消息到worker.

## What do I need? 我需要啥

Celery需要一个消息处理中介来发送和接收消息. RabbitMQ和Redis的broker传输是功能齐全的, 但是也支持其他的实验性解决方案, 包括使用本地开发的SQLite.

## Celery简述

![pic](./structure.png)

Celery 是 Python 语言实现的分布式队列服务, 除了支持即时任务, 还支持定时任务, Celery 有5个核心角色.  

*1. Task*
任务(Task)就是你要做的事情, 例如一个注册流程里面有很多任务, 给用户发验证邮件就是一个任务, 这种耗时任务可以交给Celery去处理, 还有一种任务是定时任务, 比如每天定时统计网站的注册人数, 这个也可以交给Celery周期性的处理.  

*2. Broker*
Broker 的中文意思是经纪人, 指为市场上买卖双方提供中介服务的人. 在Celery中它介于生产者和消费者之间经纪人, 这个角色相当于数据结构中的队列. 例如一个Web系统中, 生产者是处理核心业务的Web程序, 业务中可能会产生一些耗时的任务, 比如短信, 生产者会将任务发送给 Broker, 就是把这个任务暂时放到队列中, 等待消费者来处理.  消费者是 Worker, 是专门用于执行任务的后台服务. Worker 将实时监控队列中是否有新的任务, 如果有就拿出来进行处理. Celery 本身不提供队列服务, 一般用 Redis 或者 RabbitMQ 来扮演 Broker 的角色

*3. Worker*
Worker 就是那个一直在后台执行任务的人, 也称为任务的消费者, 它会实时地监控队列中有没有任务, 如果有就立即取出来执行.

*4. Beat*
Beat 是一个定时任务调度器, 它会根据配置定时将任务发送给 Broker, 等待 Worker 来消费.

*5. Backend*
Backend 用于保存任务的执行结果, 每个任务都有返回值, 比如发送邮件的服务会告诉我们有没有发送成功, 这个结果就是存在Backend中, 当然我们并不总是要关心任务的执行结果.

## 应用

使用Celery的常见场景如下:  

1. Web应用.  
用户触发的一个操作需要较长时间才能执行完成时, 可以把它作为任务交给Celery去异步执行, 执行完再返回给用户.  这段时间用户不需要等待, 提高了网站的整体吞吐量和响应时间.  

2. 定时任务.  
生产环境经常会跑一些定时任务. 假如你有上千台的服务器, 上千种任务, 定时任务的管理很困难, Celery可以帮助我们快速在不同的机器设定不同种任务.  

3. 同步  
完成的附加工作都可以异步完成. 比如发送短信/邮件, 推送消息, 清理/设置缓存等.  
